<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MarkDown语法笔记</title>
      <link href="/2024/08/31/mdyufa/"/>
      <url>/2024/08/31/mdyufa/</url>
      
        <content type="html"><![CDATA[<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>写法如下，，前有多少个**#**就代表是第几级标题</p> <figure class="highlight plaintext"><figcaption><span>一级标题</span></figcaption><table><tr><td class="code"><pre><span class="line">#一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>注意# 后要空一个才是标题</p><h1 id="二、段落"><a href="#二、段落" class="headerlink" title="二、段落"></a>二、段落</h1><h4 id="无序段落"><a href="#无序段落" class="headerlink" title="无序段落"></a>无序段落</h4><p>写法是在内容前加上 <strong>+ 或 * 或 -</strong> ，三个符号效果一至</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ a//形式一</span><br><span class="line"></span><br><span class="line">- b//形式二</span><br><span class="line"></span><br><span class="line">* c//形式三</span><br></pre></td></tr></table></figure><ul><li>1</li></ul><ul><li>2</li></ul><h4 id="有序段落"><a href="#有序段落" class="headerlink" title="有序段落"></a>有序段落</h4><p> 内容在前面加上**数字和.(英文字符)**即可，例如<br> 1.<br> 2.</p><h4 id="段落的嵌套使用"><a href="#段落的嵌套使用" class="headerlink" title="段落的嵌套使用"></a>段落的嵌套使用</h4><p>可以在有序列表中嵌套新的有序列表，也可以在无序列表中嵌套新的无序列表。<br>使用是在嵌套列表前，按住<strong>TAB</strong> 或是 <strong>空格</strong> 即可</p><h1 id="三、换行"><a href="#三、换行" class="headerlink" title="三、换行"></a>三、换行</h1><p>在一行的末尾添加两个或多个空格，然后按回车键,即可换行 </p><p>1  </p><p>2</p><h1 id="四、引用说明"><a href="#四、引用说明" class="headerlink" title="四、引用说明"></a>四、引用说明</h1><p>类似标题，在于引用内容前加上 &gt; ，有多少个 &gt; 就表示 几级引用。<br>引用说明区块还可以嵌套使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;一级</span><br><span class="line">&gt;&gt;二级</span><br><span class="line">&gt;&gt;&gt;三级</span><br><span class="line">&gt;&gt;&gt;&gt;四级</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;五级</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;六级</span><br></pre></td></tr></table></figure><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p><blockquote><p>四级引用</p><blockquote><p>五级引用</p><blockquote><p>六级引用</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="五、代码块"><a href="#五、代码块" class="headerlink" title="五、代码块"></a>五、代码块</h1><p>在代码首尾使**&#96;&#96;&#96;（英文字符）**按键在ESC下面 例如    </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"> printf(&quot;hehe\n&quot;);</span><br><span class="line"> return 0;   </span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"> printf(&quot;hehe\n&quot;);</span><br><span class="line"> return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、链接"><a href="#六、链接" class="headerlink" title="六、链接"></a>六、链接</h1><p>名称的具体内容可以不用写，但我个人<strong>建议写上</strong>，方便日后检查。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Markdown语法](网址内容 &quot;最好的markdown教程&quot;)   </span><br><span class="line">或是    </span><br><span class="line">&lt;网址内容&gt;</span><br></pre></td></tr></table></figure><p>两种写法效果不一样<br>  <a href="https://markdown.com.cn/">Markdown语法</a><br>  <a href="https://markdown.com.cn/basic-syntax/links.html">https://markdown.com.cn/basic-syntax/links.html</a>   </p><h1 id="七、图片"><a href="#七、图片" class="headerlink" title="七、图片"></a>七、图片</h1><p>我个人认为图片是MD语法中对初学者最不友好的一类。<br>插入的图片分为两类：</p><ul><li>链接图片</li><li>本地图片</li></ul><h4 id="链接图片写法"><a href="#链接图片写法" class="headerlink" title="链接图片写法"></a>链接图片写法</h4><pre><code>方法1：![图片说明](图片链接)方法2：&lt;img src=&quot;图片链接&quot;&gt;</code></pre><h4 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h4><pre><code>  方法1：![图片说明](Images/test.jpg)   //相对位置前一个是文件夹名，后一个是图片名    方法2：&lt;img src=&quot;./Images/test.jpg&quot;&gt;  </code></pre><h1 id="八、强调"><a href="#八、强调" class="headerlink" title="八、强调"></a>八、强调</h1><ul><li><p>粗体</p><ul><li><p>在内容前后各自加上<strong>两个</strong>星号或是下划线，例如</p></li><li><pre><code>**粗体**__粗体__<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      </span><br><span class="line">      **粗体**</span><br><span class="line">      __粗体__</span><br><span class="line">    </span><br><span class="line">+ 斜体</span><br><span class="line">    + 在内容前后添加**一个**星号或下划线，例如</span><br><span class="line">      </span><br><span class="line">    + ```</span><br><span class="line">      *斜体*</span><br><span class="line">      _斜体_</span><br></pre></td></tr></table></figure>*斜体*_斜体_</code></pre></li></ul></li><li><p>粗体+斜体</p><ul><li><p>在内容前后各添加<strong>三个</strong>星号，例如</p></li><li><pre><code>***粗体+斜体***<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      </span><br><span class="line">      ***粗体+斜体***</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 下划线</span><br><span class="line">  + 在内容前后各添加&lt;u&gt;和&lt;/u&gt;，例如</span><br><span class="line">  </span><br><span class="line">  + ```</span><br><span class="line">    &lt;u&gt;内容&lt;/u&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><u>内容</u></p></li></ul></li><li><p>删除线</p><ul><li><p>在内容前后各添加<strong>两个</strong> ~~，例如</p></li><li><pre><code>~~内容~~<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">  + </span><br><span class="line">    </span><br><span class="line">    ~~内容~~</span><br><span class="line">  </span><br><span class="line">+ 分割线</span><br><span class="line">   + 可用三个以上的**— * _**来建立一个分隔线，行内不能有其他内容。也可以在星号或是减号中间插入空格，例如：</span><br><span class="line"></span><br><span class="line">   + ```</span><br><span class="line">      ****</span><br><span class="line">      _____</span><br><span class="line">      _______</span><br></pre></td></tr></table></figure>  ***</code></pre></li></ul></li></ul><h1 id="九、表格"><a href="#九、表格" class="headerlink" title="九、表格"></a>九、表格</h1><p>用 <strong>|</strong> 来分隔不同的单元格<br>用 <strong>-</strong> 来分隔表头和其他行</p><table><thead><tr><th></th><th>title1</th><th>title2</th><th>title3</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td></tr><tr><td>2</td><td></td><td></td><td></td></tr></tbody></table><p><img src="/2024/08/31/mdyufa/PixPin_2024-09-11_12-44-08.png" alt="表格"></p><h1 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h1><ul><li><p>字体</p><ul><li>字体类型的设置只能在电脑上才能显示字体效果，在手机上无法显示字体类型。<br> <font face="黑体">黑体</font><br><font face="宋体">宋体</font><br><font face="楷体">楷体</font><br><font face="华文行楷">华文行楷</font><br><font face="华文隶书">华文隶书</font><br><font face="华文新魏">华文新魏</font></li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font face=&quot;黑体&quot;&gt;黑体&lt;/font&gt; </span><br><span class="line">&lt;font face=&quot;宋体&quot;&gt;宋体&lt;/font&gt; </span><br><span class="line">&lt;font face=&quot;楷体&quot;&gt;楷体&lt;/font&gt; </span><br><span class="line">&lt;font face=&quot;华文行楷&quot;&gt;华文行楷&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;华文肃书&quot;&gt;华文肃书&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;华文新魏&quot;&gt;华文新魏&lt;/font&gt;</span><br></pre></td></tr></table></figure></li><li><p>字体大小</p><ul><li><p>size为1：<font size="1">size为1</font><br>size为2：<font size="2">size为2</font><br>size为3：<font size="3">size为3</font><br>size为4：<font size="4">size为4</font></p><p>size为6:<font size="5">size为5</font></p><p>size为6：<font size="6">size为6</font></p></li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font size=&quot;1&quot;&gt;size为1&lt;/font&gt;</span><br><span class="line">&lt;font size=&quot;2&quot;&gt;size为2&lt;/font&gt;</span><br><span class="line">&lt;font size=&quot;3&quot;&gt;size为3&lt;/font&gt;</span><br><span class="line">&lt;font size=&quot;4&quot;&gt;size为4&lt;/font&gt;</span><br><span class="line">&lt;font size=&quot;5&quot;&gt;size为5&lt;/font&gt;</span><br><span class="line">&lt;font size=&quot;6&quot;&gt;size为6&lt;/font&gt;</span><br></pre></td></tr></table></figure></li><li><p>背景颜色</p><ul><li>按照十六进制颜色值来设置背景颜色<table><tr><td bgcolor="#FF6347">红色</td></tr></table>  <table><tr><td bgcolor="#F4A460">橙色</td></tr></table> <table><tr><td bgcolor="#FFD700">黄色</td></tr></table></li></ul></li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF6347&gt;红色&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;  </span><br><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#F4A460&gt;橙色&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; </span><br><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FFD700&gt;黄色&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; </span><br></pre></td></tr></table></figure><p>如需更详细的了解MD语法，可去如下网站：<br><a href="https://markdown.com.cn/basic-syntax/">https://markdown.com.cn/basic-syntax/</a>  </p><p><a href="https://blog.csdn.net/weiCong_Ling/article/details/130895397?ops_request_misc=%257B%2522request%255Fid%2522%253A%252214C8A71E-CABA-4F94-AF9D-A37DFD91814C%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=14C8A71E-CABA-4F94-AF9D-A37DFD91814C&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-130895397-null-null.142%5Ev100%5Econtrol&utm_term=md%E8%AF%AD%E6%B3%95&spm=1018.2226.3001.4187a">CSDN</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn学习心得</title>
      <link href="/2024/08/31/pwnxuexirumen/"/>
      <url>/2024/08/31/pwnxuexirumen/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言"><a href="#c语言" class="headerlink" title="c语言"></a>c语言</h1><h2 id="c标注库"><a href="#c标注库" class="headerlink" title="c标注库"></a>c标注库</h2><p> c标准库包含了一组头文件，这些头文件提供了许多函数和宏，用于处理输入输出、字符串操作、数学计算、内存管理等常见编程任务。<br> 若要使用C标准语言库中的函数，首先需要包含相应的头文件。例如，如果要调用printf函数，程序中需包含&lt;stdio.h&gt;头文件。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main ()&#123;</span><br><span class="line">printf(&quot;hello world&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> c标准库大致分为如下几类<br>  <strong>输入输出操作</strong>如&lt;stdio.h&gt;<br>  <strong>字符串处理</strong> 如&lt;string.h&gt;<br>  <strong>数学计算</strong> 如&lt;math.h&gt;<br>  <strong>内存管理</strong> 如&lt;stdlib.h&gt;<br>  <strong>时间处理</strong> 如&lt;time.h&gt;<br>  所以头文件的功能如下图所示<br><img src="/2024/08/31/pwnxuexirumen/PixPin_2024-08-31_16-28-53.png" alt="头文件"><br>如需更详细了解可去<a href="https://www.runoob.com/cprogramming/c-standard-library.html">https://www.runoob.com/cprogramming/c-standard-library.html</a></p><hr><h2 id="c语言不安全函数"><a href="#c语言不安全函数" class="headerlink" title="c语言不安全函数"></a>c语言不安全函数</h2><ol><li><p>gets</p><ul><li><code>gets</code>读取用户输入文本，但gets不会检查缓冲区大小，这很有可能导致栈溢出。</li><li>解决方法：<br> 使用 <code>fgets</code>函数代替gets函数,限制读取输入文本的大小</li></ul></li><li><p><strong>strcat</strong></p><ul><li><p>连接两个字符数组中的字符串，把字符串2接到字符串1的后面，结果放在字符串1中，函数调用后得到的值就是是字符串1的地址 </p></li><li><p>解决办法：</p><p>使用<code>strncat</code>来代替strcat，<code>strncat</code>允许指定复制的最大字符数.</p></li></ul></li><li><p><strong>strcmp</strong></p><ul><li><p>比较两个字符串的内容。但它不处理<code>NULL</code>指针或空字符串。如果输入的字符串是<code>NULL</code>，则会导致程序崩溃。</p></li><li><p>解决办法: </p><p>在使用 <code>strcmp</code> 之前，确保传入的字符串指针已初始化，并且不是空指针。否则，传递空指针可能导致程序崩溃。</p></li></ul></li><li><p><strong>scanf</strong>  </p><ul><li><p><code>scanf()</code>在处理输入时没有明确限制输入的长度，比如使用%s时，没有限定输入长度，可能导致缓冲区溢出。</p></li><li><p>解决办法：</p><p>使用<code>%Ns</code>来限制输入的最大长度，或使用<code>fgets()</code>结合<code>sscanf()</code>来更好地控制输入</p></li></ul></li><li><p><strong>strcpy</strong></p><ul><li><p>将将源字符串复制到目标缓冲区，它也不会检查目标缓冲区的大小，从而导致栈溢出。</p></li><li><p>解决方法：<br>可以使用<code>strncpy()</code>，它允许指定复制的最大字符数，但要保留一位长度用来储存\0（size-1）.</p></li></ul></li></ol><p>由我个人浅薄的认知而言，大部分c语言危险函数都是不检查缓存区导致的，所导致的问题基本上也是栈溢出这类，解决办法往往也是限制读取字符的大小，防止其超过缓冲区的大小。</p><p><a href="https://www.cnblogs.com/balingybj/p/4730795.html">相关链接</a></p><hr><h2 id="c语言常见漏洞"><a href="#c语言常见漏洞" class="headerlink" title="c语言常见漏洞"></a>c语言常见漏洞</h2><p>在了解漏洞之前，我们需要知道什么是**<u>栈和堆</u>**。</p><h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a><strong>栈（Stack）</strong></h3><p><strong>1. 内存分配方式</strong></p><ul><li>栈是一种<strong>后进先出（LIFO，Last In First Out）</strong>的数据结构。每次函数调用时，<u>局部变量、函数参数和返回地址</u>等信息会被压入栈中。</li><li>栈的分配是<strong>自动的</strong>，当函数调用时，系统会自动为其分配内存；当函数返回时，这些内存会被自动释放。</li></ul><p><strong>2. 存储内容</strong></p><ul><li>栈主要存储局部变量、函数参数、返回地址以及栈帧相关的元数据。</li><li>每个线程都有一个独立的栈，栈空间较小（通常在几MB的范围内），它的大小在程序开始时就确定了。</li></ul><p><strong>3. 内存分配速度</strong></p><ul><li>栈上的内存分配和释放速度非常快，因为栈是连续的内存区域，分配和释放只是调整栈指针（<code>ESP</code>或<code>RSP</code>）的位置。由于栈的结构简单，系统只需要移动栈指针，无需进行复杂的管理。</li></ul><p><strong>4. 生命周期</strong></p><ul><li>栈上的数据是<strong>临时的</strong>，局部变量在函数调用期间有效，当函数返回时，栈上的内存自动释放，局部变量不再有效。这意味着栈上的数据只能在有限的时间内存在，函数结束后，栈上的数据就不再可用。</li></ul><p><strong>5. 内存限制</strong></p><ul><li>栈的大小是有限的，通常系统为每个线程分配一定大小的栈（例如4MB或8MB）。如果递归太深或者分配了太多的局部变量，可能会导致<strong>栈溢出（Stack Overflow）</strong>。</li></ul><hr><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a><strong>堆（Heap）</strong></h3><p><strong>1. 内存分配方式</strong></p><ul><li>堆是一块<strong>动态分配的内存区域</strong>，用于存储在程序运行期间动态申请的内存（通过<code>malloc</code>、<code>calloc</code>、<code>new</code>等函数或操作符）。</li><li>堆内存的分配和释放是<strong>手动的</strong>，程序员负责申请内存并在不需要时释放内存。如果忘记释放，就会导致<strong>内存泄漏</strong>。</li></ul><p><strong>2. 存储内容</strong></p><ul><li>堆主要用于存储动态分配的数据，例如<u>大型数据结构（如数组、链表、树等）</u>和<u>需要跨函数生命周期的数据</u>。</li><li>堆中的内存区域较大，通常比栈的内存空间大得多，大小可以根据需要动态增长（取决于系统的可用内存）。</li></ul><p><strong>3. 内存分配速度</strong></p><ul><li>相比栈，堆上的内存分配和释放要<strong>慢得多</strong>，因为堆的内存是由操作系统管理的，需要查找空闲块、更新内存管理结构等操作，这些都增加了时间开销。</li></ul><p><strong>4. 生命周期</strong></p><ul><li>堆上的数据具有更长的生命周期，内存可以一直存在，直到程序手动释放（调用<code>free</code>或<code>delete</code>）。这使得堆内存非常适合存储需要跨多个函数或线程使用的数据。</li><li>如果程序不及时释放堆内存，会导致<strong>内存泄漏</strong>，长时间运行的程序可能会因为内存泄漏导致内存耗尽。</li></ul><p><strong>5. 内存限制</strong></p><ul><li><p>堆的大小没有栈那么严格的限制，它可以动态增长，理论上可以使用系统可用内存的绝大部分。然而，堆内存的使用如果管理不当，可能会导致<strong>内存碎片化</strong>，降低分配效率。</p><hr></li></ul><table><thead><tr><th></th><th>栈（stack）</th><th>堆（head）</th></tr></thead><tbody><tr><td><strong>内存分配方式</strong></td><td>由编译器自动分配和释放</td><td>由程序员手动分配和释放</td></tr><tr><td><strong>分配速度</strong></td><td>非常快，直接在栈顶分配或释放</td><td>较慢，内存分配需要进行复杂的管理操作</td></tr><tr><td><strong>存储内容</strong></td><td>局部变量、函数参数、返回地址</td><td>动态分配的内存块，适合存储大对象或动态数据</td></tr><tr><td><strong>内存大小</strong></td><td>栈空间通常较小（系统设置有限），如几MB</td><td>堆空间通常较大，受限于系统可用内存量</td></tr><tr><td><strong>访问方式</strong></td><td>通过栈帧直接访问（LIFO），效率高</td><td>通过指针访问，效率较低</td></tr><tr><td><strong>生命周期</strong></td><td>随函数调用开始，随函数返回结束收</td><td>程序员控制，生命周期较长</td></tr><tr><td>安全性</td><td>相对安全，有栈溢出保护（如栈金丝雀、ASLR）</td><td>内存泄漏、双重释放、UAF等问题</td></tr><tr><td><strong>用途</strong></td><td>用于局部变量、函数参数、临时数据等</td><td>用于动态数据结构（如链表、树、图等）或大型对象</td></tr><tr><td><strong>增长方向</strong></td><td>从高地址向低地址增长</td><td>从低地址向高地址增长</td></tr></tbody></table><hr><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p><strong>1. 缓冲区溢出（Buffer Overflow）</strong></p><p>缓冲区溢出是：指<u>程序试图将数据写入超出预定缓冲区大小的内存地址</u>。这种情况通常发生在<strong>数组、字符串</strong>等固定大小的内存区域上。</p><p>缓冲区溢出并<strong>不局限于栈或堆</strong>，它可以发生在任意的内存区域。</p><p><strong>2. 栈溢出（Stack Overflow）</strong></p><p>栈溢出是：<u>程序试图在栈上分配超出栈空间限制的数据量时，导致栈内存超出预分配的区域</u>。导致栈溢出的原因大致分为<strong>两种</strong>：一是存储的数据超过预分配的栈空间；二是递归函数没有设置正确的结束条件，一直进行下去，直到占满栈的空间。</p><p> <strong>3. 堆溢出（Heap Overflow）</strong></p><p>堆溢出是：<u>程序在操作堆内存时，超出了预期的内存大小，</u>可能会导致覆盖其他堆中的数据或破坏堆管理器的元数据，进而导致程序崩溃或安全漏洞。</p><p><strong>4. 内存泄漏（Memory Leak）</strong></p><p>内存泄漏是：<u>程序动态分配了堆内存后未能正确释放，导致内存无法被回收，随着时间推移，系统可用内存逐渐减少</u>，最终导致程序崩溃或系统资源耗尽。</p><p> <strong>5. 使用后释放漏洞（Use-After-Free, UAF）</strong></p><p>UAF漏洞是：<u>程序在释放了堆内存后，继续访问或修改已释放的内存</u>，可能导致程序崩溃或攻击者利用该漏洞执行恶意代码。</p><p><strong>6. 格式化字符串漏洞(Format String Vulnerability)</strong></p><p><strong>7. 双重释放（Double Freee）</strong></p><p><strong>8. 越界一位漏洞(Off-by-One)</strong></p><p><strong>9. 文件结构相关的漏洞(IO_FILE)</strong></p><p><strong>10.整数溢出（Integer Overflow）</strong></p><h1 id="code分析及其危害"><a href="#code分析及其危害" class="headerlink" title="code分析及其危害"></a>code分析及其危害</h1><h2 id="code-1"><a href="#code-1" class="headerlink" title="code 1"></a>code 1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //引入标准输入输出库</span><br><span class="line">#include &lt;stdlib.h&gt;//引入标准库</span><br><span class="line">#include &lt;string.h&gt;//引入字节处理库</span><br><span class="line">int main() &#123;</span><br><span class="line">char buf[0x20]; //定义一个char类型的数组大小为32字节</span><br><span class="line">while(1) &#123;   //死循环</span><br><span class="line">puts(&quot;Hello pwner, give me a content and then I&#x27;ll repeat it: &quot;);//输出语句</span><br><span class="line">gets(buf);//危险函数get，用来读取输入的字符串到buf</span><br><span class="line">if (buf[0] == &#x27;#&#x27;) &#123;//若第一个字符是#</span><br><span class="line">puts(&quot;Exiting...&quot;);//输出Exiting...</span><br><span class="line">break;//跳出循环</span><br><span class="line"> &#125;</span><br><span class="line">puts(&quot;You said is: &quot;);//若第一个字符不是#，输出You said is</span><br><span class="line">puts(buf);//输出用户输入的buf</span><br><span class="line"> &#125;</span><br><span class="line">return 0;//程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用了<strong>gets（）</strong>函数，若读取的文本超出缓存区大小，就有可能造成漏洞</p><hr><h2 id="code2"><a href="#code2" class="headerlink" title="code2"></a>code2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;//引入标准输入输出库</span><br><span class="line"> #include &lt;stdlib.h&gt;//引入标准库</span><br><span class="line"> #include &lt;string.h&gt;//引入字节处理库</span><br><span class="line"> #include &quot;mycustom.h&quot;  // import custom functions or datas</span><br><span class="line"> int main() &#123;</span><br><span class="line"> char buf[0x100];//定义一个char类型的数组，大小为256字节</span><br><span class="line"> char* password = getRandomString(); // this function will return a random string </span><br><span class="line">with 32 bytes</span><br><span class="line"> password[1] = &#x27;\x00&#x27;;//定义password的第二个字符为字符串结束符</span><br><span class="line"> puts(&quot;Welcome to pwn system, Tell me the password: &quot;);//输出Welcome to pwn system, Tell me the password</span><br><span class="line"> read(0, buf, 0x20);//从标准输入读取至多32字节给buf</span><br><span class="line"> if(!strcmp(buf, password)) &#123;//比较输入的密码和生成的密码</span><br><span class="line"> puts(&quot;Authentication success.&quot;);//输出Authentication success.</span><br><span class="line"> system(&quot;/bin/sh&quot;);//执行系统命令</span><br><span class="line">  &#125;</span><br><span class="line"> else &#123;</span><br><span class="line"> puts(&quot;Authentication failed!&quot;);//否则输出Authentication failed</span><br><span class="line">  &#125;</span><br><span class="line"> return 0;//程序结束</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>使用了危险函数<strong>strcmp，</strong>若输入的密码为空,即<code>NULL</code>就有可能导致程序崩溃.</p><hr><h2 id="code-3、"><a href="#code-3、" class="headerlink" title="code 3、"></a>code 3、</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //引入标准输入输出库</span><br><span class="line"> #include &lt;unistd.h&gt; // 引入 UNIX 标准库，包含对 read() 函数的支持</span><br><span class="line"> #include &lt;stdlib.h&gt;//引入标准库</span><br><span class="line"> #include &lt;string.h&gt;//引入字节处理库</span><br><span class="line"> int main() &#123;</span><br><span class="line"> char buf[0x100];//定义一个char类型的数组，大小为256字节</span><br><span class="line"> puts(&quot;Hello pwner, tell me your name: &quot;);//输出Hello pwner, tell me your name:</span><br><span class="line"> read(0, buf, 0x100);//从标准输入读取至多256字节给buf</span><br><span class="line"> printf(&quot;Welcome &quot;);//输出Welcoe</span><br><span class="line"> printf(buf);//输出用户输入的buf</span><br><span class="line"> printf(&quot;, nice to meet you!\n&quot;);//输出, nice to meet you!并换行</span><br><span class="line"> if(!strncmp(&quot;DetLFY&quot;, buf, 6)) &#123;//比较buf的前六的字符是否与DetlFY一至</span><br><span class="line"> puts(&quot;Someone let me ask you if you need anything?&quot;);//输出Someone let me ask you if you need anything?</span><br><span class="line"> read(0, buf, 0x200);//从标准输入读取至多512字节给buf</span><br><span class="line"> puts(&quot;Okay, I will convey it.&quot;);//输出Okay, I will convey it</span><br><span class="line">  &#125;</span><br><span class="line"> else &#123;</span><br><span class="line"> puts(&quot;Bye.&quot;);//输出Bye</span><br><span class="line">  &#125;</span><br><span class="line"> return 0;//程序结束</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 使用了read(0, buf, 0x200); 企图读取<strong>512字节到256字节大小的 buf</strong> ，这将导致缓冲区溢出。</p><hr><h2 id="code-4、"><a href="#code-4、" class="headerlink" title="code 4、"></a>code 4、</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;//引入标准输入输出库</span><br><span class="line"> #include &lt;unistd.h&gt;// 引入 UNIX 标准库，包含对 read() 函数的支持</span><br><span class="line"> #include &lt;stdlib.h&gt;//引入标准库</span><br><span class="line"> #include &lt;string.h&gt;//引入字节处理库</span><br><span class="line"> struct Note &#123;//定义结构体Note</span><br><span class="line"> unsigned int size;//声明一个类型为 unsigned int 的变量size</span><br><span class="line"> char* content;//声明一个char类型的指针c指向ontent</span><br><span class="line"> &#125; notes[16];//定义一个数组note，最多可储存16个note</span><br><span class="line"> void menu() &#123;//定义一个函数menu</span><br><span class="line"> puts(&quot;1. Add note&quot;);//输出1. Add note</span><br><span class="line"> puts(&quot;2. Delete note&quot;);//输出2. Delete note</span><br><span class="line"> puts(&quot;3. Edit note&quot;);//输出3. Edit note</span><br><span class="line"> puts(&quot;4. Show note&quot;);//输出4. Show note</span><br><span class="line"> puts(&quot;5. Exit&quot;);//输出5. Exit</span><br><span class="line"> printf(&quot;&gt;&gt; &quot;);//打印&gt;&gt;</span><br><span class="line"> &#125;</span><br><span class="line"> void add() &#123;//定义函数add</span><br><span class="line"> int idx;//声明一个int类型的变量 idx</span><br><span class="line"> puts(&quot;idx?&quot;);//输出idx？</span><br><span class="line"> scanf(&quot;%d&quot;, &amp;idx);//将用户输入的值赋给idx</span><br><span class="line"> if(idx &lt; 16 &amp;&amp; notes[idx].content == NULL) &#123;//若idx小于16且·组[idx]储存的content为空</span><br><span class="line"> puts(&quot;size?&quot;);//输出size?</span><br><span class="line"> scanf(&quot;%u&quot;, &amp;notes[idx].size);//读取note大小</span><br><span class="line"> if(notes[idx].size &lt; 0x500) &#123;//检查note大小是否小于1280字节</span><br><span class="line"> notes[idx].content = malloc(notes[idx].size);//分配内存content</span><br><span class="line"> puts(&quot;Done.&quot;);//输出done</span><br><span class="line"> return;//返回</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> puts(&quot;Failed.&quot;);//输出Failed。</span><br><span class="line"> &#125;</span><br><span class="line"> void delete() &#123;//定义函数delete</span><br><span class="line"> int idx;//声明一个int类型的变量 idx</span><br><span class="line"> puts(&quot;idx?&quot;);//输出idx？</span><br><span class="line"> scanf(&quot;%d&quot;, &amp;idx);//将用户输入的值赋给idx</span><br><span class="line"> if(idx &lt; 16 &amp;&amp; notes[idx].content != NULL) &#123;//若idx小于16且数组[idx]储存的content不为空</span><br><span class="line">free(notes[idx].content);//释放note占用的内存</span><br><span class="line"> puts(&quot;Done.&quot;);//输出Done。</span><br><span class="line"> return;//返回</span><br><span class="line">  &#125;</span><br><span class="line"> puts(&quot;Failed.&quot;);//输出失败</span><br><span class="line"> &#125;</span><br><span class="line"> void edit() &#123;//定义一个函数edit</span><br><span class="line"> int idx;//声明一个int类型的变量 idx</span><br><span class="line"> puts(&quot;idx?&quot;);//输出idx？</span><br><span class="line"> scanf(&quot;%d&quot;, &amp;idx);//将用户输入的值赋给idx</span><br><span class="line"> if(idx &lt; 16 &amp;&amp; notes[idx].content != NULL) &#123;//若idx小于16且数组[idx]储存的content不为空</span><br><span class="line"> puts(&quot;Content?&quot;);//输出Content</span><br><span class="line"> if(notes[idx].size &gt; 0) &#123;//若note[idx]的大小大于0</span><br><span class="line"> read(0, notes[idx].content, notes[idx].size);//读取用户输入的content到note[idx]</span><br><span class="line"> puts(&quot;Done.&quot;);//输出Done.</span><br><span class="line"> return;//返回</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> puts(&quot;Failed.&quot;);//输出Failed.</span><br><span class="line"> &#125;</span><br><span class="line"> void show() &#123;//定义一个函数show</span><br><span class="line"> int idx;//声明一个int类型的变量 idx</span><br><span class="line"> puts(&quot;idx?&quot;);//输出idx？</span><br><span class="line"> scanf(&quot;%d&quot;, &amp;idx);//将用户输入的值赋给idx</span><br><span class="line"> if(idx &lt; 16 &amp;&amp; notes[idx].content != NULL) &#123;//若idx小于16且数组[idx]储存的content不为空</span><br><span class="line"> write(1, notes[idx].content, notes[idx].size);//将note[idx].content的内容写入到标准输出</span><br><span class="line"> puts(&quot;Done.&quot;);//输出Done.</span><br><span class="line"> return;//返回</span><br><span class="line">  &#125;</span><br><span class="line"> puts(&quot;Failed.&quot;);//输出Failed.</span><br><span class="line"> &#125;</span><br><span class="line"> int main() &#123;</span><br><span class="line"> unsigned int choice;//声明一个 unsigned int 类型的变量choice</span><br><span class="line"> while(1) &#123;//死循环</span><br><span class="line"> menu();//显示menu</span><br><span class="line"> scanf(&quot;%u&quot;, &amp;choice);//读取用户的choice</span><br><span class="line"> switch(choice) &#123;//分支函数switch</span><br><span class="line"> case 1:</span><br><span class="line"> add();//1add函数</span><br><span class="line"> break;//跳出循环</span><br><span class="line"> case 2:</span><br><span class="line"> delete();//2delete函数</span><br><span class="line"> break;//跳出循环</span><br><span class="line">case 3:</span><br><span class="line"> edit();//3edit函数</span><br><span class="line"> break;//跳出循环</span><br><span class="line"> case 4:</span><br><span class="line"> show();//4show函数</span><br><span class="line"> break;//跳出循环</span><br><span class="line"> case 5:</span><br><span class="line"> exit(1);//5退出</span><br><span class="line"> default://默认</span><br><span class="line"> continue;//继续循环</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> return 0;//程序结束</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>add函数那一块，使用了scanf函数，尽管检查了size的大小，但是没有考虑size的值<strong>是否为负数</strong>，有可能导致整数溢出。</p><p>在edit函数那一块，使用了read将用于输入的content读取给notes[idx].size，若content的大小超出notes[idx].size，就有可能导致UAF漏洞。</p><hr><h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="汇编语言-1"><a href="#汇编语言-1" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>  我们平日里学习的编程语言，属于高级语言，但计算机无法直接理解，需要通过编译器（例如gcc）将高级语言转换成二进制代码（操作码），这样计算机才能理解。计算机真正能够理解的是低级语言，它专门用来控制硬件。而汇编语言就是低级语言，用于直接操作计算机硬件，例如寄存器、内存等等。</p><p>  对于人来说，二进制程序是不可读的，难以看不出来机器究竟干了什么。为了解决这个问题，于是就有了汇编语言。汇编语言是机械指令的文本形式，与指令是一一对应。比如，加法指令00000011写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行。</p><p>​这里又有了个新的概念，什么是指令。指令通常由<u>操作码，操作数和寻访地址</u>组成</p><ul><li><p>机械指令：CPU可直接识别和执行的二进制编码</p></li><li><p>汇编指令：机器指令的助记符（缩写居多），同机器指令一一对应。</p><ul><li>汇编指令</li></ul><ul><li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行。</li><li>其他符号：如+、-、*、&#x2F;等。</li></ul></li></ul><h2 id="寄存器（Registers）"><a href="#寄存器（Registers）" class="headerlink" title="寄存器（Registers）"></a>寄存器（Registers）</h2><p>寄存器（Registers）是计算机数据储存方式之一，它位于CPU内部，是CPU内部元件之一，用于暂存CPU执行指令和数据。在储存器中，寄存器的处理速度是最快的（1ns），同时也是造价最昂贵。</p><p>在更具体的了解寄存器之前，我们要简单了解**<u>CPU</u>**内部的架构</p><h3 id="CPU架构"><a href="#CPU架构" class="headerlink" title="CPU架构"></a>CPU架构</h3><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>CPU ：中央处理器，是计算机硬件的核心部件，大致由<strong>运算器，控制器，寄存器和总线</strong>组成。前三个部分由总线连接起来。</p><p>其中，运算器大致分为：</p><ul><li><p>累加器ACC</p></li><li><p>寄存器</p></li><li><p><u>算术逻辑单位ALU</u>等等</p></li></ul><p>控制器则分为：</p><ul><li><p><u>控制单元CU</u></p></li><li><p>指令寄存器IR</p></li><li><p>程序计数器PC等等</p><hr><p><strong>粗浅了解一下CPU的核心组件，大致如下：</strong></p></li></ul><ol><li><p><strong>控制单元（Control Unit, CU）</strong></p><ul><li><strong>功能</strong>：取指令，解释这些指令，并发送到CPU的各个部分来执行指令。</li><li><strong>工作原理</strong>：通过协调其他单元（如ALU、寄存器）的工作，控制单元确保每个指令按照设定的顺序执行。</li></ul></li><li><p><strong>算术逻辑单元（Arithmetic Logic Unit, ALU）</strong></p><ul><li><strong>功能</strong>：ALU是CPU中执行算术运算（加减乘除）和逻辑运算（与或非等）的部分。</li><li><strong>工作原理</strong>：ALU从寄存器获取操作数，执行操作并将结果存储到寄存器中。</li></ul></li><li><p><strong>寄存器（Registers）</strong></p><ul><li><strong>功能</strong>：寄存器是CPU中的小型存储单元，用于暂时保存数据和指令。</li></ul></li></ol><ul><li><p><strong>重要性</strong>：寄存器能够极大提高CPU处理数据的效率，它们与CPU直接连接，访问速度极快（1ns）。</p><hr></li></ul><p><img src="/2024/08/31/pwnxuexirumen/f82e3124211cf7f5acb260fa43f05d28.png"></p><h4 id="冯诺依曼体系"><a href="#冯诺依曼体系" class="headerlink" title="冯诺依曼体系"></a>冯诺依曼体系</h4><p>1945年提出的冯诺依曼体系结构是现代计算机的基础。这套理论的基本思想即为：指令和数据存储在同一内存中，由此程序指令和数据的宽度相同。此外，他还提出了计算机的三个原则，即为计算机由五个部分组成（运算器，控制器，储存器，输出设备，输入设备）、程序存储执行和二进制逻辑。</p><p>根据冯诺依曼体系，CPU的工作分为以下 5 个阶段：<u>取指令阶段、指令译码阶段、执行指令阶段、访存取数和结果写回</u>。</p><ol><li>取指令：<ol start="2"><li>指令编译：</li><li>执行指令：</li><li>访存取数：</li><li>结果回读：</li></ol></li></ol><hr><h3 id="寄存器类型："><a href="#寄存器类型：" class="headerlink" title="寄存器类型："></a>寄存器类型：</h3><h4 id="通用寄存器（General-Purpose-Registers）"><a href="#通用寄存器（General-Purpose-Registers）" class="headerlink" title="通用寄存器（General Purpose Registers）"></a>通用寄存器（General Purpose Registers）</h4><p>通用寄存器用于存储数据和地址。每个寄存器可以作为32位（在x86-32位架构中）或64位（在x86-64位架构中）来操作。在32位模式下，寄存器前缀为<code>E</code>，在64位模式下，前缀为<code>R</code>。这些寄存器可用于存储整数、地址、结果等数据。</p><ol><li><p><strong>累加寄存器AX（Accumulator）</strong></p><p>·用于算术运算，累加寄存器。很多指令默认使用它进行结果存储。。</p></li></ol><ul><li><p><strong>EAX</strong>（32位）</p></li><li><p><strong>AX</strong>（16位）</p></li><li><p><strong>RAX</strong>(64位)</p></li><li><p><strong>AH&#x2F;AL</strong>(8位)</p></li></ul><ol start="2"><li><p><strong>基址寄存器BX（Base Register）</strong></p><p>·通常用于存储基址（Base Address），例如内存中的数据地址。</p></li></ol><ul><li><strong>EBX</strong>（32位）</li><li><strong>BX</strong>（16位）</li><li><strong>RBX</strong>(64位)</li></ul><ol start="3"><li><p><strong>计数寄存器CX（Count Register）</strong></p><p>·用于循环计数操作和字符串操作。</p></li></ol><ul><li><p><strong>ECX</strong>（32位）</p></li><li><p><strong>CX</strong>（16位）</p></li><li><p><strong>RCX</strong>(64位)</p></li></ul><ol start="4"><li><p><strong>数据寄存器DX(Date Register)</strong></p><p>·在乘除和I&#x2F;O，通常用于存储被除数或商和余数。</p></li></ol><ul><li><strong>EDX</strong>（32位）</li><li><strong>DX</strong>（16位）</li><li><strong>RDX</strong>（64位)</li></ul><p><u>AX、BX、CX、DX</u> 都可以独立当作两个<strong>8位</strong>寄存器来使用。</p><ul><li>AX 分为 <strong>AH</strong> 和 <strong>AL</strong></li><li>BX 分为 <strong>BH</strong> 和 <strong>BL</strong> </li><li>CX 分为 <strong>CL</strong> 和 <strong>CL</strong> </li><li>DX 分为 <strong>DH</strong> 和 <strong>DL</strong></li></ul><ol start="5"><li><strong>其他</strong></li></ol><ul><li><strong>源索引寄存器ESI</strong>（32位）通常用于字符串操作中，作为源数据的指针。</li><li><strong>目标索引寄存器EDI</strong>（32位）通常用于字符串操作中，作为目标数据的指针。</li><li><strong>基址指针寄存器EBP</strong>（32位）通常用于存储栈帧基地址，帮助访问函数参数和局部变量。</li><li><strong>栈指针寄存器ESP</strong>（32位）指向当前栈顶，用于管理函数调用和局部变量。</li><li><strong>64位架构新增的寄存器 R8-R15</strong>（64位）在64位x86架构中，额外增加了8个通用寄存器（R8到R15）。这些寄存器没有直接的 32 位版本，但可以通过细分为 32 位、16 位和8位子寄存器进行操作。</li></ul><h4 id="段寄存器（Segment-Registers）"><a href="#段寄存器（Segment-Registers）" class="headerlink" title="段寄存器（Segment Registers）"></a>段寄存器（Segment Registers）</h4><p>段寄存器用于分段内存寻址，早期x86架构通过分段机制来管理内存。虽然现代处理器很少直接使用段寄存器，但在保护模式下它们仍然有一定作用。</p><ul><li><strong>CS（代码段寄存器）</strong>：保存当前代码段的基址，决定当前执行的代码所在的段。</li><li><strong>DS（数据段寄存器）</strong>：保存数据段的基址，决定数据存储位置。</li><li><strong>SS（栈段寄存器）</strong>：保存栈段的基址，指向当前栈所在的内存段。</li><li><strong>ES、FS、GS</strong>：用于额外的段存取，特别是在特定的系统调用或结构访问中有特殊用途。</li></ul><h4 id="指令指针寄存器（Instruction-Pointer）"><a href="#指令指针寄存器（Instruction-Pointer）" class="headerlink" title="指令指针寄存器（Instruction Pointer）"></a>指令指针寄存器（Instruction Pointer）</h4><p><strong>EIP</strong>（32位）：指向下一条将要执行的指令的内存地址，通常随着指令的执行自动增加。在64位架构中，对应的是<strong>RIP</strong>。</p><ul><li><strong>RIP</strong>（64位）：64位模式下的指令指针，存储当前执行的指令地址。</li></ul><h4 id="状态寄存器（Flags-Register）"><a href="#状态寄存器（Flags-Register）" class="headerlink" title="状态寄存器（Flags Register）"></a>状态寄存器（Flags Register）</h4><p>状态寄存器存储处理器当前的状态信息，特别是在条件判断、跳转等操作中起作用。</p><ul><li><p>EFLAGS</p><p>（32位）：保存当前运算的状态标志，如进位、零标志、溢出标志等。常用标志位：</p><ul><li><strong>ZF（Zero Flag）</strong>：运算结果是否为零。如果为零，则设置该标志。</li><li><strong>CF（Carry Flag）</strong>：进位标志，表示加法或减法运算是否产生了进位或借位。</li><li><strong>SF（Sign Flag）</strong>：符号标志，表示结果是正数还是负数。</li><li><strong>OF（Overflow Flag）</strong>：溢出标志，用于检测有符号运算的溢出。</li></ul></li><li><p>RFLAGS：</p><p>（64位）：</p></li></ul><h4 id="控制寄存器（Control-Registers）"><a href="#控制寄存器（Control-Registers）" class="headerlink" title="控制寄存器（Control Registers）"></a>控制寄存器（Control Registers）</h4><p>控制寄存器用于管理处理器的运行模式和特权级控制。</p><ul><li><p><strong>CR0</strong>：控制处理器的模式，如保护模式、虚拟内存启用等。</p></li><li><p><strong>CR2</strong>：保存导致页面错误的地址（在虚拟内存中）。</p></li><li><p><strong>CR3</strong>：页表基址寄存器，用于分页机制下的内存管理。</p></li><li><p><strong>CR4</strong>：启用某些特性，如页面大小扩展、调试扩展等。</p><hr></li></ul><h3 id="x86-64架构的寄存器"><a href="#x86-64架构的寄存器" class="headerlink" title="x86-64架构的寄存器"></a>x86-64架构的寄存器</h3><p>在64位计算机架构中，寄存器的大小<strong>从32位扩展到64位</strong>，这使得它们能够处理更大范围的数据和地址。64位寄存器可以存储更多的数据，并且在64位处理器上运行的软件能够利用更大的内存空间和改进的性能。</p><h2 id="内存栈（Memory-stack）"><a href="#内存栈（Memory-stack）" class="headerlink" title="内存栈（Memory stack）"></a>内存栈（Memory stack）</h2><p>内存栈（stack）是计算机内存中的一个重要数据结构，广泛用于存储函数调用的信息、局部变量、返回地址等。栈是一种<strong>后进先出（LIFO，Last In First Out）</strong>的数据结构，这意味着最后压入栈中的元素会第一个被弹出。</p><h3 id="内存栈的基本概念"><a href="#内存栈的基本概念" class="headerlink" title="内存栈的基本概念"></a>内存栈的基本概念</h3><ol><li><strong>栈的结构</strong>：<ul><li><strong>栈顶（Top）</strong>：当前栈的最上面的位置，最后插入的元素。所有的栈操作都从栈顶进行。</li><li><strong>栈底（Bottom）</strong>：栈的起始位置，通常在内存中的固定位置。</li></ul></li><li><strong>栈的操作</strong>：<ul><li><strong>压栈（Push）</strong>：将数据项放入栈顶。每次压栈后，栈顶指针向下移动。</li><li><strong>弹栈（Pop）</strong>：从栈顶移除数据项。每次弹栈后，栈顶指针向上移动。</li><li><strong>查看栈顶（Peek&#x2F;Top）</strong>：查看栈顶元素但不移除它。</li></ul></li></ol><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>常见的指令大致有：</p><h3 id="1-数据传输指令"><a href="#1-数据传输指令" class="headerlink" title="1. 数据传输指令"></a>1. 数据传输指令</h3><p><u><strong>用于在不同的存储区域之间移动数据，比如在寄存器、内存和外部设备之间传输。</strong></u></p><ul><li><strong>MOV（Move）</strong><br><strong>作用</strong>：将一个操作数的值传输到另一个位置。<br><strong>格式</strong>：<code>MOV 目的操作数, 源操作数</code><br><strong>例子</strong>：<code>MOV AX, BX</code><br><strong>含义</strong>：将寄存器 <code>BX</code> 中的数据复制到寄存器 <code>AX</code> 中。<br><strong>原理</strong>：操作系统通过总线系统将源操作数的数据放入目的操作数中。这并不是简单地交换数据，而是复制数据。</li><li><strong>PUSH（入栈）</strong><br><strong>作用</strong>：将一个操作数的值压入栈中。<br><strong>格式</strong>：<code>PUSH 操作数</code><br><strong>例子</strong>：<code>PUSH AX</code><br><strong>含义</strong>：将寄存器 <code>AX</code> 的内容压入栈顶。<br><strong>原理</strong>：处理器会将栈指针（SP）的值减小，并将 <code>AX</code> 的数据存入新的栈顶位置。</li><li><strong>POP（出栈）</strong><br><strong>作用</strong>：从栈顶弹出一个操作数的值。<br><strong>格式</strong>：<code>POP 操作数</code><br><strong>例子</strong>：<code>POP AX</code><br><strong>含义</strong>：将栈顶的值弹出，并存入寄存器 <code>AX</code> 中。<br><strong>原理</strong>：处理器将栈顶的内容存入目的寄存器，同时栈指针（SP）的值增大，表示栈顶位置的变化。</li><li><strong>LOAD</strong><br><strong>作用</strong>：从内存中读取数据到寄存器中。<br><strong>格式</strong>：<code>LOAD 目的寄存器, 地址</code><br><strong>例子</strong>：<code>LOAD AX, [1234]</code><br><strong>含义</strong>：从内存地址 <code>1234</code> 中读取数据，并将其存入寄存器 <code>AX</code> 中。<br><strong>原理</strong>：处理器通过地址总线找到内存中的具体位置，将数据读取并存入寄存器。</li><li><strong>STORE</strong><br><strong>作用</strong>：将寄存器的数据写入到内存中。<br><strong>格式</strong>：<code>STORE 地址, 寄存器</code><br><strong>例子</strong>：<code>STORE [1234], AX</code><br><strong>含义</strong>：将寄存器 <code>AX</code> 中的数据存入内存地址 <code>1234</code> 中。<br><strong>原理</strong>：处理器通过地址总线定位到内存中的指定位置，然后通过数据总线将寄存器的数据写入到该位置。</li></ul><hr><h3 id="2-算术运算指令"><a href="#2-算术运算指令" class="headerlink" title="2. 算术运算指令"></a>2. 算术运算指令</h3><p><u><strong>用于执行基本的数学运算，如加法、减法、乘法和除法。</strong></u></p><ul><li><strong>ADD（加法）</strong><br><strong>作用</strong>：对两个操作数执行加法运算。<br><strong>格式</strong>：<code>ADD 目的操作数, 源操作数</code><br><strong>例子</strong>：<code>ADD AX, BX</code><br><strong>含义</strong>：将寄存器 <code>BX</code> 和 <code>AX</code> 中的数据相加，结果存入 <code>AX</code>。<br><strong>原理</strong>：处理器的算术逻辑单元（ALU）负责进行加法操作。它将两个操作数进行二进制相加，并更新处理器的标志位（如进位标志位、零标志位）。</li><li><strong>SUB（减法）</strong><br><strong>作用</strong>：对两个操作数执行减法运算。<br><strong>格式</strong>：<code>SUB 目的操作数, 源操作数</code><br><strong>例子</strong>：<code>SUB AX, BX</code><br><strong>含义</strong>：将寄存器 <code>BX</code> 中的数据从 <code>AX</code> 中减去，结果存入 <code>AX</code>。<br><strong>原理</strong>：处理器的ALU进行二进制减法运算，结果存储在目的操作数，并更新相关的标志位。</li><li><strong>MUL（乘法）</strong><br><strong>作用</strong>：对两个操作数执行无符号乘法运算。<br><strong>格式</strong>：<code>MUL 源操作数</code><br><strong>例子</strong>：<code>MUL BX</code><br><strong>含义</strong>：将寄存器 <code>AX</code> 中的数据和 <code>BX</code> 中的数据相乘，结果存入寄存器 <code>AX</code> 和 <code>DX</code>。<br><strong>原理</strong>：ALU进行二进制乘法，并根据乘法结果将高位存储在 <code>DX</code>，低位存储在 <code>AX</code>。</li><li><strong>DIV（除法）</strong><br><strong>作用</strong>：对两个操作数执行无符号除法运算。<br><strong>格式</strong>：<code>DIV 源操作数</code><br><strong>例子</strong>：<code>DIV BX</code><br><strong>含义</strong>：将寄存器 <code>AX</code> 和 <code>DX</code> 中的数据作为被除数，<code>BX</code> 为除数，商存入 <code>AX</code>，余数存入 <code>DX</code>。<br><strong>原理</strong>：处理器将两个寄存器的组合数据作为被除数，执行二进制除法。</li></ul><hr><h3 id="3-逻辑运算指令"><a href="#3-逻辑运算指令" class="headerlink" title="3. 逻辑运算指令"></a>3. 逻辑运算指令</h3><p><u><strong>用于执行按位逻辑操作，例如与（AND）、或（OR）、非（NOT）等。</strong></u></p><ul><li><strong>AND（按位与）</strong><br><strong>作用</strong>：对两个操作数执行按位与运算。<br><strong>格式</strong>：<code>AND 目的操作数, 源操作数</code><br><strong>例子</strong>：<code>AND AX, BX</code><br><strong>含义</strong>：对 <code>AX</code> 和 <code>BX</code> 中的数据进行按位与操作，结果存入 <code>AX</code>。<br><strong>原理</strong>：AND运算将两个操作数按位进行比较，当且仅当两个对应位都为1时，结果为1，否则为0。</li><li><strong>OR（按位或）</strong><br><strong>作用</strong>：对两个操作数执行按位或运算。<br><strong>格式</strong>：<code>OR 目的操作数, 源操作数</code><br><strong>例子</strong>：<code>OR AX, BX</code><br><strong>含义</strong>：对 <code>AX</code> 和 <code>BX</code> 中的数据进行按位或操作，结果存入 <code>AX</code>。<br><strong>原理</strong>：OR运算将两个操作数按位进行比较，只要有一个位为1，结果为1，否则为0。</li><li><strong>XOR（按位异或）</strong><br><strong>作用</strong>：对两个操作数执行按位异或运算。<br><strong>格式</strong>：<code>XOR 目的操作数, 源操作数</code><br><strong>例子</strong>：<code>XOR AX, BX</code><br><strong>含义</strong>：对 <code>AX</code> 和 <code>BX</code> 中的数据进行按位异或操作，结果存入 <code>AX</code>。<br><strong>原理</strong>：XOR运算只有当两个位不相同时，结果为1；否则结果为0。</li><li><strong>NOT（按位取反）</strong><br><strong>作用</strong>：对操作数的每个位进行取反操作。<br><strong>格式</strong>：<code>NOT 操作数</code><br><strong>例子</strong>：<code>NOT AX</code><br><strong>含义</strong>：对 <code>AX</code> 中的每个位进行取反操作。<br><strong>原理</strong>：NOT运算将每个位的1变为0，0变为1。</li></ul><hr><h3 id="4-控制指令"><a href="#4-控制指令" class="headerlink" title="4. 控制指令"></a>4. 控制指令</h3><p><u><strong>用于改变程序执行的流程，比如跳转、函数调用等。</strong></u></p><ul><li><strong>JMP（无条件跳转）</strong><br><strong>作用</strong>：无条件地将程序控制权转移到指定地址。<br><strong>格式</strong>：<code>JMP 地址</code><br><strong>例子</strong>：<code>JMP 1234H</code><br><strong>含义</strong>：程序的执行跳转到内存地址 <code>1234H</code>。<br><strong>原理</strong>：处理器将程序计数器（PC）设置为指定地址，使程序从该地址继续执行。</li><li><strong>CALL（调用子程序）</strong><br><strong>作用</strong>：调用一个子程序，并在执行完成后返回。<br><strong>格式</strong>：<code>CALL 地址</code><br><strong>例子</strong>：<code>CALL 5678H</code><br><strong>含义</strong>：调用位于地址 <code>5678H</code> 的子程序，子程序完成后返回。<br><strong>原理</strong>：处理器将当前程序计数器的值压入栈中，然后跳转到子程序地址。子程序执行完后，通过 <code>RET</code> 指令返回原来的位置。</li><li><strong>RET（返回）</strong><br><strong>作用</strong>：从子程序返回到主程序。<br><strong>格式</strong>：<code>RET</code><br><strong>原理</strong>：从栈中弹出返回地址，并跳转到该地址继续执行主程序。</li></ul><hr><h3 id="5-输入-输出指令"><a href="#5-输入-输出指令" class="headerlink" title="5. 输入&#x2F;输出指令"></a>5. 输入&#x2F;输出指令</h3><p><u><strong>用于与外部设备交换数据，如从键盘读取输入，向显示器输出结果。</strong></u></p><ul><li><strong>IN（输入）</strong><br><strong>作用</strong>：从指定的I&#x2F;O端口读取数据。<br><strong>格式</strong>：<code>IN 寄存器, 端口</code><br><strong>例子</strong>：<code>IN AX, 60H</code><br><strong>含义</strong>：从端口 <code>60H</code> 读取数据并存入寄存器 <code>AX</code> 中。<br><strong>原理</strong>：通过I&#x2F;O总线从外部设备读取数据并放入寄存器。</li><li><strong>OUT（输出）</strong><br><strong>作用</strong>：将寄存器中的数据输出到指定的I&#x2F;O端口。<br><strong>格式</strong>：<code>OUT 端口, 寄存器</code><br><strong>例子</strong>：<code>OUT 60H, AX</code><br><strong>含义</strong>：将寄存器 <code>AX</code> 中的数据输出到端口 <code>60H</code>。<br><strong>原理</strong>：通过I&#x2F;O总线将寄存器的数据发送到外部设备。</li></ul><hr><h3 id="6-条件控制指令"><a href="#6-条件控制指令" class="headerlink" title="6. 条件控制指令"></a>6. 条件控制指令</h3><p><u><strong>用于根据某个条件是否成立来决定是否跳转执行另一段代码</strong></u>。</p><ul><li><strong>JZ（如果零则跳转）</strong><br><strong>作用</strong>：如果零标志位（ZF）为1，则跳转到指定地址。<br><strong>格式</strong>：<code>JZ 地址</code><br><strong>例子</strong>：<code>JZ 1234H</code><br><strong>含义</strong>：如果前一条指令的结果为0，则跳转到地址 <code>1234H</code>。<br><strong>原理</strong>：处理器检查零标志位，如果标志位为1，则改变程序计数器的值以跳转。</li><li><strong>JNZ（如果非零则跳转）</strong><br><strong>作用</strong>：如果零标志位（ZF）为0，则跳转到指定地址。<br><strong>格式</strong>：<code>JNZ 地址</code><br><strong>例子</strong>：<code>JNZ 5678H</code><br><strong>含义</strong>：如果前一条指令的结果不为0，则跳转到地址 <code>5678H</code>。<br><strong>原理</strong>：检查零标志位是否为0，如果为0则程序继续从指定地址执行。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用vscode写hexo博客</title>
      <link href="/2024/08/11/hexoxiebokexuzhi/"/>
      <url>/2024/08/11/hexoxiebokexuzhi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在写md文件之前，建议先学习一下md语法和搭建好写md的语言环境，尤其是关于插入图片这一方面的（这里推荐使用<strong>pinpix</strong>截图工具）。本文将会帮助你用<strong>vscode</strong>和相关的插件写md文件，但md语法并不会写在这里，请另外搜寻。</p><h2 id="一、vscode的推荐插件"><a href="#一、vscode的推荐插件" class="headerlink" title="一、vscode的推荐插件"></a>一、vscode的推荐插件</h2><p>   写MD的文件一般推荐使用，但我个人时使用vscode加相关插件。如果你也想使用vscode写md文件，我强力推荐你安装如下插件。<br>   1、<strong>Markdown All in One</strong><br>   <img src="/2024/08/11/hexoxiebokexuzhi/2024-08-11-13-18-31.png" alt="Markdown All in One"></p><table><thead><tr><th>快捷键</th><th>效果</th></tr></thead><tbody><tr><td>ctrl + b</td><td>加粗</td></tr><tr><td>ctrl + i</td><td>斜体</td></tr><tr><td>ctrl + shift + [</td><td>下一级标题</td></tr><tr><td>ctrl + shift + ]</td><td>上一级标题</td></tr><tr><td>ctrl + M</td><td>不换行数学公式</td></tr><tr><td>Alt + S</td><td>删除线</td></tr></tbody></table><p>   是vscode写Markdown语言的必装插件：包含了键盘快捷键，自动预览等等。<br>   <img src="/2024/08/11/hexoxiebokexuzhi/PixPin_2024-08-11_13-30-15.png" alt="快捷键"><br>   2、<strong>Markdown Preview Enhanced</strong><br>   <img src="/2024/08/11/hexoxiebokexuzhi/2024-08-11-13-19-26.png" alt="Markdown Preview Enhanced"><br>   点击右上角的的按键，即可预览md文件的效果<br>   <img src="/2024/08/11/hexoxiebokexuzhi/2024-08-11-13-21-27.png"><br>   预览效果如下<br>   <img src="/2024/08/11/hexoxiebokexuzhi/image-1.png" alt="预览"></p><p>   3、<strong>Paste Image</strong><br>   <img src="/2024/08/11/hexoxiebokexuzhi/image.png" alt="Paste Image"><br>   作用时，按住<strong>CTRL+ALT＋V</strong>将图片复制到md文件中</p><h2 id="二、-config设置"><a href="#二、-config设置" class="headerlink" title="二、_config设置"></a>二、_config设置</h2><p>   打开blog根目录的config文件，找到 <strong>post_asset_folder</strong> 一项，将flase改为true，这样一来在新建md文件后，会自动生成一个同名文件夹，我个人喜欢将图片保存到此处。（注意新建文件时最好不要出现中文）<br>   <img src="/2024/08/11/hexoxiebokexuzhi/PixPin_2024-08-11_13-02-04.png" alt="config"><br>   <img src="/2024/08/11/hexoxiebokexuzhi/PixPin_2024-08-11_13-39-28.png" alt="config"></p><h2 id="三、截图工具pinpix"><a href="#三、截图工具pinpix" class="headerlink" title="三、截图工具pinpix"></a>三、截图工具pinpix</h2><p>   初次使用前先点击pinpix启动 &gt;&gt; 打开任务栏 &gt;&gt; 鼠标右键点击 &gt;&gt; 打开配置勾选开机自启动，这样方便以后日常使用。截图后，点击最右侧的选项（复制并关闭），按住<strong>CTRL+ALT＋V</strong>将图片地址复制到md文档中。<br>   <img src="/2024/08/11/hexoxiebokexuzhi/2024-08-11-13-15-33.png" alt="配置">   <img src="/2024/08/11/hexoxiebokexuzhi/2024-08-11-13-16-05.png" alt="开机自启动"><br>   但保存截图时，若显示，鼠标右键点击文件夹打开属性 &gt;&gt; 找到安全 &gt;&gt; 点击编辑 &gt;&gt; 将权限中的写入勾选上。<br>   <img src="/2024/08/11/hexoxiebokexuzhi/2024-08-11-13-11-49.png" alt="属性"><br>   具体操作及其功能，请自行移步至pinpix官网<a href="https://pixpinapp.com/">https://pixpinapp.com/</a>,这里不作详细介绍。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建虚拟机</title>
      <link href="/2024/08/09/xuniji/"/>
      <url>/2024/08/09/xuniji/</url>
      
        <content type="html"><![CDATA[<p>  利用VMware来搭建ubuntu的虚拟机，我将在这篇博客记录下载过程以及个人心得。同时，我会将他人详细教程视频放在文末，如有兴趣可自行观看。</p><h1 id="一、下载VMware"><a href="#一、下载VMware" class="headerlink" title="一、下载VMware"></a>一、下载VMware</h1><p>  先是到VMware的官网上下载软件，在安装完成后，点击许可证，输入密钥即可永久使用（自己找）。<br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_16-27-17.png" alt="截图2"><br>  随后，出现如下情款说明激活成功。<br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_16-34-19.png" alt="截图3"><br>  随后，下载ubuntu的光盘映像文件（我在文末附上的教学视屏有）。下载完后，准备阶段结束，进入下一阶段。</p><h1 id="二、自定义设置"><a href="#二、自定义设置" class="headerlink" title="二、自定义设置"></a>二、自定义设置</h1><p>  进入虚拟机页面，打开文件&gt;&gt;打开新建虚拟机向导，出现如下弹窗，选择第二个自定义选项<br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_16-37-29.png" alt="弹窗"><br>  下一步中，选择第三个选项<br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_16-41-18.png" alt="弹窗1"><br>  客户机操作系统选择Linux,Version选择ubuntu 64位。<br>  随后依次自定义虚拟机各项属性，按照图片所示一一进行配置<br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_16-48-00.png" alt="弹窗2"><br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_16-48-34.png" alt="弹窗3"><br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_16-48-45.png" alt="弹窗4"><br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_16-48-53.png" alt="弹窗5"><br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_16-49-01.png" alt="弹窗6"><br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_16-49-10.png" alt="弹窗7"><br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_16-49-20.png" alt="弹窗8"></p><h1 id="三、网络配置检查和虚拟机设置"><a href="#三、网络配置检查和虚拟机设置" class="headerlink" title="三、网络配置检查和虚拟机设置"></a>三、网络配置检查和虚拟机设置</h1><p>  在打开虚拟机之前，先检查以太网网络配置，先打开windows的系统，找到网络和internet，打开高级网络设置，找到相关设置下的&gt;更多网络适配器设置。若出现如下弹窗显示已开启，则设置成功.<br>   <img src="/2024/08/09/xuniji/PixPin_2024-08-08_17-00-04.png" alt="网络"><br>   打开vm，找到左侧的设置，打开其中的CD&#x2F;DVD(SATA),打开后在连接那一栏，选择第二个选项，将之前下载的ubuntu的光盘映像文件打开。<br>   <img src="/2024/08/09/xuniji/PixPin_2024-08-08_17-02-44.png" alt="光盘1"><br>   <img src="/2024/08/09/xuniji/PixPin_2024-08-08_17-03-02.png" alt="光盘2"><br>   虚拟机启动后，进入ubuntu界面，开始设置一些基本内容，将语言选为中文后，选择安装ubuntu。<br>   <img src="/2024/08/09/xuniji/PixPin_2024-08-08_17-10-16.png" alt="语言" title="语言"><br>   键盘语言选择Chinese，下一步，取消安装ubuntu时更新，选择现在安装后，时区选为上海<br>   <img src="/2024/08/09/xuniji/PixPin_2024-08-08_17-10-56.png" alt="安装"><br>   <img src="/2024/08/09/xuniji/PixPin_2024-08-08_17-11-12.png" alt="安装2"><br>   注册完账户，等待一段时间（10-20分钟），取决于电脑性能，最后ubuntu如下<br>   <img src="/2024/08/09/xuniji/PixPin_2024-08-08_17-11-41.png" alt="注册"></p><h1 id="四、我遇见的报错"><a href="#四、我遇见的报错" class="headerlink" title="四、我遇见的报错"></a>四、我遇见的报错</h1><p>  若隔天，若vm出现如下情况，鼠标右键选择一管理员身份运行<br>  <img src="/2024/08/09/xuniji/PixPin_2024-08-08_17-21-18.png" alt="错"></p><h1 id="五、拍摄快照"><a href="#五、拍摄快照" class="headerlink" title="五、拍摄快照"></a>五、拍摄快照</h1><p>   鼠标右键点击Ubuntu &gt;&gt; 点击快照 &gt;&gt; 再点击拍摄快照即可<br> <img src="/2024/08/09/xuniji/PixPin_2024-08-09_16-36-00.png" alt="照"></p><p> vm下载<a href="https://www.bilibili.com/video/BV1rd4y1G71H/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1rd4y1G71H/?spm_id_from=333.337.search-card.all.click</a></p><p> ubuntu下载教程<a href="https://www.bilibili.com/video/BV1M94y1U7nc/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1M94y1U7nc/?spm_id_from=333.337.search-card.all.click</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客网站的心得</title>
      <link href="/2024/08/05/dajiangerenboke/"/>
      <url>/2024/08/05/dajiangerenboke/</url>
      
        <content type="html"><![CDATA[<p>   这篇博客主要是为了记下我在搭建个人博客网站的心路历程与碰上的问题，也算是一个教程。我会在这篇文章简述我遇见的问题和解决办法，希望您在看完这篇博客的时候也有所感受。</p><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><p>   搭建hexo个人博客之前，我们需要下载前置软件<strong>git和node.js</strong>。<br>   git的官网是  <a href="https://git-scm.com/">https://git-scm.com/</a><br>   node.js的官网是  <a href="http://nodejs.cn/">http://nodejs.cn/</a>。<br>   但要注意一下node.js的版本最好下载稳定版。此外，我们还需要一个github的账号，注册好之后开始搭建博客的第一步。</p><h2 id="二、创建个人仓库"><a href="#二、创建个人仓库" class="headerlink" title="二、创建个人仓库"></a>二、创建个人仓库</h2><p>  我们先打开gitthub，如图<br><img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-08_14-37-56.png" alt="创建仓库"><br>  随后，<br><img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-08_14-47-05.png" alt="命名仓库"><br>  建好后，准备安装git和Node.js,并配置node.js的环境。</p><h2 id="三、安装git和node-js"><a href="#三、安装git和node-js" class="headerlink" title="三、安装git和node.js"></a>三、安装git和node.js</h2><p> 我们首先来安装git，相较于node.js的环境配置而言，安装则更简单。在安装完后，我们按住win＋r唤出运行窗口，输入cmd，然后输入以下命令，来检查是否安装成功，如有相应版本信息显示则安装成功。若未能出现版本信息，请重新安装。<br><img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-08_15-05-33.png" alt="版本"></p><p>下载完后，打开node.js的文件夹，在该目录内新建两个文件夹，node_global、node_cache<br><img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-09_17-15-09.png" alt="两文件夹"></p><h2 id="四、配置node-js环境变量"><a href="#四、配置node-js环境变量" class="headerlink" title="四、配置node.js环境变量"></a>四、配置node.js环境变量</h2><p> 1、打开windows设置 &gt;&gt; 点击系统 &gt;&gt; 点击系统设置 &gt;&gt; 点击高级系统设置<br> <img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-09_17-02-03.png" alt="系统设置"></p><p> 2、点击后弹出系统属性 &gt;&gt; 点击环境变量 &gt;&gt; 在系统变量那一栏点击新建 &gt;&gt; 变量名中输入NODE_HOME &gt;&gt; 变量值则是你安装的node.JS的路径<br> <img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-09_17-06-43.png" alt="环境变量"></p><p> 3、在系统变量那一栏找到Path &gt;&gt; 新建 &gt;&gt; 依次输入红框内的文字<br> <img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-09_17-57-45.png" alt="路径"></p><h2 id="五、SSH密钥"><a href="#五、SSH密钥" class="headerlink" title="五、SSH密钥"></a>五、SSH密钥</h2><p>1、打开git，若是第一次使用git，先输入如下两条代码，确定你的身份<br><code>$ git config --global user.name &quot;Your Name&quot;</code><br><code>$ git config --global user.email &quot;email@example.com&quot;</code><br>要注意这里输入的用户名和邮箱要与你的github账号一致，输入完后可以输入如下代码检查<br><code>git config --global --list</code><br> <img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-09_17-49-10.png" alt="检查"></p><p> 2、输入如下命令，一直回车，获取两种密钥。<br> <code>$ ssh-keygen -t rsa -C &quot;your email@example.com&quot; </code><br>再运行以下命令，粘贴密钥，或是找到密钥所在处&#x2F;c&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa.pub.，自己复制。但要注意密钥有两种，复制类型为pub的那个。<br><code>$ clip &lt; ~/.ssh/id_rsa.pub</code><br><img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-09_17-57-45.png" alt="密钥"></p><p>3、打开github &gt;&gt; 点击右上方的头像 &gt;&gt;点击setting &gt;&gt; 在左侧找到SSH and GPH keys &gt;&gt;点击 New SSH key &gt;&gt;依次输入titile和密钥<br><img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-09_18-07-34.png" alt="设置密钥"></p><h2 id="六、安装hexo"><a href="#六、安装hexo" class="headerlink" title="六、安装hexo"></a>六、安装hexo</h2><p> hexo的官网<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a><br> 1、任意选择一个磁盘，新建一个文件夹myblog，之后博客相关文件就可以放在此文件夹下，鼠标邮件点击该文件夹，点击 Git Bash Here，输入 npm 命令安装hexo。<br> <code>npm install hexo-cli -g</code><br> <code>npm install hexo-deployer-git --save</code><br>  第一个命令表示安装 hexo，第二个命令表示安装 hexo 部署到 git page 的 deployer，如图所示即为安装成功</p><p> 2、安装完后，在刚才新建的文件夹里面再次新建一个blog文件夹（E\myblog\blog）,进入该 文件夹后右键鼠标，点击 Git Bash Here，输入以下命令，如图所示则安装成功<br><code>hexo init</code><br>安装完后，打开文件夹，会出现很多新文件，说明安装成功<br> <img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-09_18-14-40.png" alt="文件"></p><p> 3、打开文件中的_config文件，将文件末改为如下图所示<br> <img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-09_22-06-43.png" alt="config"><br> 打开刚刚创建的github仓库 &gt;&gt; 点击code &gt;&gt; 切换至ssh &gt;&gt; 复制<br> <img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-09_22-08-32.png" alt="复制"></p><p> 4、此时，输入hexo s 作用是启动本地服务器，用于预览主题。出现：<br> <img src="/2024/08/05/dajiangerenboke/PixPin_2024-08-09_22-03-05.png" alt="本地"><br> ps(这里出现butteerfly，是因为我用的是butterfly的主题)</p><h2 id="七、创见博客"><a href="#七、创见博客" class="headerlink" title="七、创见博客"></a>七、创见博客</h2><p> 依次在blog目录下用Git Bash Here打开并输入如下命令：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new “文章名称”#创建博客</span><br><span class="line">hexo g#生成</span><br><span class="line">hexo s#本地预览</span><br><span class="line">hexo d#部署</span><br></pre></td></tr></table></figure></p><h2 id="八、个人心得"><a href="#八、个人心得" class="headerlink" title="八、个人心得"></a>八、个人心得</h2><p>在报错的时侯，将报错内容输入给ai是个不错的选择。我个人推荐使用chatgpt。当然，关于ai的使用，只能说仁者见仁智者见智，不管使用什么ai都行。但使用ai时，一定要分辨错对。有些时候，ai的回答是为了答而答，对解决问题毫无帮助.对此问题，我建议在CSDN内搜索同样的问题，两者结合起来一起使用，来解决报错。</p><p>此外在搭建博客网址前，我奉劝各位挑选教程视频或是文章时，一定要关注文章是什么时候的，过早的文章或视频可能不在适应当下。例如，之前branch：是master，但是现在github更新后默认使用main。另外，在搭建博客的准备阶段，我建议多方求证，多看看各种教程，有些教程的方法不一定详尽，有些搭建步骤是可调换的，例如ssh这一步骤，但对网站的搭建没什么影响。</p><p>这是我个人一些小小的感悟，在文末我会附上我个人推荐的文章或是视频。</p><p> nodejs搭建视频 <a href="https://www.bilibili.com/video/BV19F411t7zX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b2faaeef3e09d3254c3f42996695ce36">https://www.bilibili.com/video/BV19F411t7zX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b2faaeef3e09d3254c3f42996695ce36</a></p><p> 搭建教程 <a href="https://blog.csdn.net/qq_36759224/article/details/82121420?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172278488516800222814587%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=172278488516800222814587&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-82121420-null-null.142%5Ev100%5Econtrol&amp;utm_term=hexo&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/qq_36759224/article/details/82121420?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172278488516800222814587%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=172278488516800222814587&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-82121420-null-null.142^v100^control&amp;utm_term=hexo&amp;spm=1018.2226.3001.4187</a></p><p> 搭建时的坑 <a href="https://blog.csdn.net/qq_59039063/article/details/132459418">https://blog.csdn.net/qq_59039063/article/details/132459418</a></p><p> 视频1，手把手教但是声音太小 <a href="https://www.bilibili.com/video/BV1cW411A7Jx/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b2faaeef3e09d3254c3f42996695ce36">https://www.bilibili.com/video/BV1cW411A7Jx/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b2faaeef3e09d3254c3f42996695ce36</a></p><p> 视频2，声音更清楚，也是手把手教但是是gitee <a href="https://www.bilibili.com/video/BV1ts4y1f7Gu/?spm_id_from=333.337.top_right_bar_window_history.content.click&amp;vd_source=b2faaeef3e09d3254c3f42996695ce36">https://www.bilibili.com/video/BV1ts4y1f7Gu/?spm_id_from=333.337.top_right_bar_window_history.content.click&amp;vd_source=b2faaeef3e09d3254c3f42996695ce36</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/05/hello-world/"/>
      <url>/2024/08/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="hello-my-blog"><a href="#hello-my-blog" class="headerlink" title="hello my blog"></a>hello my blog</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
